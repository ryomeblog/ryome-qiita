---
title: Java基礎編
tags:
  - Java
private: false
updated_at: '2022-05-01T01:14:26+09:00'
id: e26b940220c213a46f7f
organization_url_name: null
slide: false
ignorePublish: false
---
# Java基礎編

------------------------------------------------------------

## プリミティブ型
- byte型：8ビット整数 -128～127
- short型：16ビット整数 -32,768～32,767
- int型：32ビット整数 -2,147,483,648～2,147,483,647
- long型：64ビット整数 -9,223,372,036,854,775,808～9,223,372,036,854,775,807
- float型：32ビット単精度浮動小数点数
- double型：64ビット倍精度浮動小数点数
- boolean型：true or false
- char型：16ビットUnicode文字 \u0000～\uFFFF

------------------------------------------------------------

## 参照型
- Object型：すべてのクラスは暗黙的にこのクラスを継承して作られる
- Byte型：8ビット整数 -128～127
- Short型：16ビット整数 -32,768～32,767
- Integer型：32ビット整数 -2,147,483,648～2,147,483,647
- Long型：64ビット整数 -9,223,372,036,854,775,808～9,223,372,036,854,775,807
- Float型：32ビット単精度浮動小数点数
- Double型：64ビット倍精度浮動小数点数
- Boolean型：true or false
- String型：文字列
...etc

------------------------------------------------------------


## アクセス修飾子
- public：どこからでもアクセス可能
- protected：同じパッケージ内のクラスまたは継承したサブクラスのみアクセス可能
- private：クラス内部からのみアクセス可能
- アクセス修飾子なし：同じパッケージ内のすべてのクラスからアクセス可能

------------------------------------------------------------

## クラス
- クラスとファイル名は共通
- 頭文字は必ず大文字
- インスタンスを作るときはコンストラクタが呼ばれる
- mainメソッドは1つしか存在できない
- コンパイルするとファイル名.classとなる
    - 実行されているのはclassファイル

クラスは以下の文章のように記述する

```
public class クラス名 {
    // mainメソッド
    public static void main(String[] args) {
        System.out.print("Hello Java");
    }
}
```

------------------------------------------------------------

## インスタンス
インスタンスの生成は以下の文章のように記述する

```
クラス名 変数名 = new クラス名(); 
```

あらかじめ、生成するクラスを作成しておく必要がある

```
class クラス名{
    // コンストラクタ（インスタンス生成時に実行される）
    クラス名(){
        初期化処理など
    }
}
```

以下、記述例

```
// インスタンスとコンストラクタのテストクラス
public class Test {
    // mainメソッド
    public static void main(String[] args) {
        // インスタンス(オブジェクト)を生成(コンストラクタ呼び出し)
        Hello hello = new Hello();
    }
}

// インスタンスのテストクラス
class Hello {
  // コンストラクタ
  Hello() {
      //Helloの表示
      System.out.print("Hello");
  }
}
```

------------------------------------------------------------

## Javadoc
- Javadocコメントは実際の処理には影響がないコメント
- Javadocコメントは `/**` と `*/` の間に コメントを記述する
- 普通のコメントアウトは `//`

以下、記述例

```
/**
 * @author 作成者名
 * @version x.x.x
 */

 /**
  * Javadocの解説用メインクラス
  */
public class Sample {
    /**
     * mainメソッド
     * @param args 使用しない
     */
    public static void main(String[] args) {
        // 文字列の表示
        System.out.println("JavaDocサンプル");
    }
}
```

------------------------------------------------------------

## オーバーロード
- 同じクラス内で同じ名前のメソッドを複数作成できる（引数を変える必要がある）

オーバーロードは以下の文章のように記述する

```
package パッケージ名;
public class メインクラス名{
    public static void main(String[] args) {
        // インスタンスの生成
        クラス名 変数名1 = new クラス名();
        クラス名 変数名2 = new クラス名(実引数);
        クラス名 変数名3 = new クラス名(変数名2と異なる型の実引数);
        クラス名 変数名4 = new クラス名(実引数1, 実引数2);
    }
}
```

あらかじめ、メソッドを複数作成したクラスを作成しておく必要がある

```
package パッケージ名;
class クラス名{
    // インスタンス変数の定義
    private 型名 変数名;

    // コンストラクタ1（引数なし）
    クラス名(){
        初期化処理など
    }
    // コンストラクタ2（引数あり）
    クラス名(型名 引数名){
        初期化処理など
    }
    // コンストラクタ3（コンストラクタ2と異なる引数あり）
    クラス名(型名 引数名){
        初期化処理など
    }
    // コンストラクタ3（引数1, 引数2）
    クラス名(型名 引数名, 型名 引数名){
        初期化処理など
    }
}
```


------------------------------------------------------------

## カプセル化
- 直接参照させたくない変数などにはprivateを頭に付ける
- privateについては[アクセス修飾子](#アクセス修飾子)を参照

カプセル化は以下の文章のように記述する

```
package パッケージ名;
public class メインクラス名{
    public static void main(String[] args) {
        // インスタンスの生成
        クラス名 変数名 = new クラス名();
        // setterに値を入れる
        変数名.setインスタンス変数名(実引数);
        // getterで入れた値の取得をする
        System.out.println(変数名.getインスタンス変数名());
    }
}
```

あらかじめ、private変数またはメソッドを持つクラスを作成しておく必要がある

```
package パッケージ名;
class クラス名{
    // インスタンス変数の定義
    private 型名 変数名;

    // コンストラクタ（インスタンス生成時に実行される）
    クラス名(){
        初期化処理など
    }
    // setter
    void setインスタンス変数名(型名 引数名){
        this.変数名 = 引数名;
    }
    // getter
    型名 getインスタンス変数名(){
        return 変数名;
    }
}
```

------------------------------------------------------------

## 継承
- スーパークラスのメソッドと同じメソッドをサブクラスでも使用できる
- スーパークラスに処理や変数を書き足したいときやあらかじめ抽象化した処理を具体的に書きたいときに使用する
- 継承はサブクラス名の後に `extends スーパークラス名` をつけることで行うことができる
- スーパークラス（親クラス）
- サブクラス（子クラス）

継承は以下の文章のように記述する

```
package パッケージ名;
class スーパークラス名{
    // インスタンス変数の定義
    private 型名 変数名;

    // コンストラクタ（インスタンス生成時に実行される）
    スーパークラス名(型名 引数){
        初期化処理など
    }
    // setter
    void setインスタンス変数名(型名 引数名){
        this.変数名 = 引数名;
    }
    // getter
    型名 getインスタンス変数名(){
        return 変数名;
    }
}
```

```
package パッケージ名;
class サブクラス名 extends スーパークラス名{
    // インスタンス変数の定義
    private 型名 変数名;

    // コンストラクタ（インスタンス生成時に実行される）
    サブクラス名(型名 引数){
        super(引数);
        初期化処理など
    }
    // setter
    void setインスタンス変数名(型名 引数名){
        this.変数名 = 引数名;
    }
    // getter
    型名 getインスタンス変数名(){
        return 変数名;
    }
}
```

------------------------------------------------------------

## オーバーライド
- スーパークラスのメソッドと同じメソッド名・引数で、 異なる処理したい場合に使用する
- スーパークラスに存在するメソッドを `@Override` をつけることでサブクラスで再定義できる
- スーパークラス（親クラス）
- サブクラス（子クラス）

オーバーライドは以下の文章のように記述する

```
class スーパークラス名 {

    // スーパークラスメソッド
    メソッド名(){
        //処理
    }
}
```

```
class サブクラス名 extends スーパークラス名 {

    // オーバーライド
    @Override
    メソッド名(){
        //処理
    }
}
```

------------------------------------------------------------

## ポリモーフィズム
- `抽象クラス` とは、 `継承されることを前提` に作られたクラスである
- `抽象クラス` 、 `抽象メソッド` は、「`abstract修飾子`」をつけて定義する
- 抽象メソッド には、 `private` / `static` / `final` 修飾子を付けることはできない
- 抽象クラス の利用は `抽象クラス` を継承し、 `サブクラス` を定義し、 `抽象メソッド` を `オーバーライド` する
- `継承` については[継承](#継承)を参照
- `オーバーライド` については[オーバーライド](#オーバーライド)を参照

ポリモーフィズムは以下の文章のように記述する

```
package パッケージ名;
class サブクラス名 extends 抽象クラス名{
    // インスタンス変数の定義
    private 型名 変数名;

    // コンストラクタ（インスタンス生成時に実行される）
    サブクラス名(型名 引数){
        super(引数);
        初期化処理など
    }
    // オーバーライド(抽象メソッド)
    @Override
    抽象メソッド名(型名 引数){
        //処理
    }
}
```

あらかじめ、抽象クラスを作成しておく必要がある

```
package パッケージ名;
abstract class 抽象クラス名{
    // インスタンス変数の定義
    private 型名 変数名;

    // コンストラクタ（インスタンス生成時に実行される）
    抽象クラス名(型名 引数){
        初期化処理など
    }
    // 抽象メソッド
    abstract 抽象メソッド名(型名 引数);
}
```

------------------------------------------------------------

## ArrayList
- Listメソッドは以下のメソッドをよく使う
- 参照型の配列
- Listは要素の順番を担保しない

| メソッド   | 説明                                                                                  | 記述例                                                |
| :--------- | :------------------------------------------------------------------------------------ | :---------------------------------------------------- |
| `add`      | リストに値を追加する。                                                                | list.add(要素番号)                                    |
| `addAll`   | リストにリストを追加する。                                                            | list1.add(リスト)                                     |
| `set`      | リストの値を変更する。                                                                | list.set(要素番号, 代入する値)                        |
| `get`      | リストの値を取得する。                                                                | list.get(要素番号)                                    |
| `size`     | リストの要素数を取得する。                                                            | list.size()                                           |
| `indexOf`  | リストから値の要素番号を取得する。                                                    | list.indexOf(検索する値)                              |
| `subList`  | リストから範囲を指定してシャローコピーする。(※元のリストと同じデータを参照している。) | subList(開始要素番号, 終了要素番号)                   |
| `contains` | リストに値が含まれるか判定する。                                                      | list.contains(検索する値)                             |
| `remove`   | リストから指定すた要素番号の値を削除する。                                            | list.remove(要素番号)                                 |
| `distinct` | リストの重複する値を削除する。                                                        | list.stream().distinct().collect(Collectors.toList()) |
| `clone`    | リストをコピーする。                                                                  | list.clone()                                          |
| `clear`    | リストを空にする。                                                                    | list.clear()                                          |

ArrayListは以下の文章のように記述する

```
package パッケージ名;
public class メインクラス名{
    public static void main(String[] args) {
        // ArrayListの作成
        List<参照型名> 変数名 = new ArrayList<参照型名>();
    }
}
```


------------------------------------------------------------

## 参考URL

- [Javaのインスタンスの使い方](https://qiita.com/ryome/items/62ba0d8395af6698053a)
- [Javadocの書き方](https://qiita.com/ryome/items/4f2d5928c8aaf195f407)
- [オーバーロードの使い方](https://qiita.com/ryome/items/f1ca8cc7538f4c6d26c0)
- [カプセル化の使い方](https://qiita.com/ryome/items/fc44dfad297b35bf7559)
- [継承の使い方](https://qiita.com/ryome/items/97b82c5519e39d3f21c1)
- [オーバーライドの使い方](https://qiita.com/ryome/items/97b82c5519e39d3f21c1)
- [ポリモーフィズムの使い方](https://qiita.com/ryome/items/a22457797988c548ec62)
- [ArrayListの使い方](https://qiita.com/ryome/items/cc01a7b6914e5b8b1579)
